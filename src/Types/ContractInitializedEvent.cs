using Concordium.Sdk.Exceptions;

namespace Concordium.Sdk.Types;

/// <summary>
/// Data generated as part of initializing a single contract instance.
/// </summary>
public class ContractInitializedEvent
{
    /// <summary>
    /// Contract version.
    /// </summary>
    public ContractVersion ContractVersion { get; init; }
    /// <summary>
    /// A reference to a smart contract module deployed on the chain.
    /// </summary>
    public ModuleReference ModuleReference { get; init; }
    /// <summary>
    /// Represents a contract address.
    /// </summary>
    public ContractAddress ContractAddress { get; init; }
    /// <summary>
    /// Represents a CCD amount.
    /// </summary>
    public CcdAmount Amount { get; init; }
    /// <summary>
    /// A contract name.
    /// </summary>
    public OwnedContractName InitName { get; init; }
    /// <summary>
    /// A list of events generated by a smart contract.
    /// </summary>
    public IList<ContractEvent> Events { get; init; }
    
    internal ContractInitializedEvent(Concordium.Grpc.V2.ContractInitializedEvent initializedEvent)
    {
        ContractVersion = initializedEvent.ContractVersion switch
        {
            Grpc.V2.ContractVersion.V0 => ContractVersion.V0,
            Grpc.V2.ContractVersion.V1 => ContractVersion.V1,
            _ => throw new MissingEnumException<Grpc.V2.ContractVersion>(initializedEvent.ContractVersion)
        };
        ModuleReference = new ModuleReference(new HashBytes(initializedEvent.OriginRef.Value));
        ContractAddress = ContractAddress.From(initializedEvent.Address);
        Amount = CcdAmount.FromMicroCcd(initializedEvent.Amount.Value);
        InitName = new OwnedContractName(initializedEvent.InitName.Value);
        Events = initializedEvent.Events
            .Select(e => new ContractEvent(e.Value.ToByteArray()))
            .ToList();
    }
}